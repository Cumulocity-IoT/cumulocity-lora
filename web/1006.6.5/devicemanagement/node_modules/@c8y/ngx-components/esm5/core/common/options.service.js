import * as tslib_1 from "tslib";
import { InjectionToken, Optional, Inject, Injectable } from '@angular/core';
import { camelCase, isUndefined } from 'lodash-es';
import { ApplicationOptions } from './ApplicationOptions';
import { SystemOptionsService, TenantOptionsService } from '@c8y/ngx-components/api';
export var HOOK_OPTIONS = new InjectionToken('App options');
/**
 * A service that allows to set or get application options
 * which configure the default behavior of the UI.
 */
var OptionsService = /** @class */ (function (_super) {
    tslib_1.__extends(OptionsService, _super);
    function OptionsService(options, systemOptionsService, tenantOptionService) {
        var _this = _super.call(this) || this;
        _this.systemOptionsService = systemOptionsService;
        _this.tenantOptionService = tenantOptionService;
        _this.setupOptions(options);
        return _this;
    }
    /**
     * Returns an application option used to configure the UI.
     * @param optionKey The application options key.
     * @param defaultValue A value to return if non is set.
     */
    OptionsService.prototype.get = function (optionKey, defaultValue) {
        var value = this[optionKey];
        if (typeof value === 'undefined') {
            value = this[camelCase(optionKey)];
        }
        return typeof value !== 'undefined' ? value : defaultValue;
    };
    /**
     * Sets an application option.
     * @param key The key to set.
     * @param value The value to set.
     */
    OptionsService.prototype.set = function (key, value) {
        this[camelCase(key)] = value;
    };
    /**
     * Gets support url from tenant options.
     * If response returns '404 not found' it gets the support url from application options.
     * If the support link within application options is not provided the UI will use the system options.
     * Is the support link explicitly set to false it will be hidden.
     * NOTE: The tenant option endpoint returns the system option setting if non is set on the tenant.
     *
     * @returns Returns support url or false.
     */
    OptionsService.prototype.getSupportUrl = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!isUndefined(this.supportUrl)) return [3 /*break*/, 2];
                        _a = this;
                        return [4 /*yield*/, this.getTenantOption('configuration', 'system.support.url')];
                    case 1:
                        _a.supportUrl = _b.sent();
                        _b.label = 2;
                    case 2: return [2 /*return*/, isUndefined(this.supportUrl) ? false : this.supportUrl];
                }
            });
        });
    };
    /**
     * Returns if the tenant allows to show the activate-support user menu entry.
     */
    OptionsService.prototype.getActivateSupportUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.getSystemOption('support-user', 'enabled', true)];
            });
        });
    };
    /**
     * Gets a value from the system service and parses it.
     *
     * @param category The category for this option.
     * @param key The key for that option.
     * @param defaultValue The default if the option was not found.
     */
    OptionsService.prototype.getSystemOption = function (category, key, defaultValue) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.getOptionFromService(category, key, this.systemOptionsService, defaultValue)];
            });
        });
    };
    /**
     * Gets a value from the tenant service and parses it.
     *
     * @param category The category for this option.
     * @param key The key for that option.
     * @param defaultValue The default if the option was not found.
     */
    OptionsService.prototype.getTenantOption = function (category, key, defaultValue) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.getOptionFromService(category, key, this.tenantOptionService, defaultValue)];
            });
        });
    };
    OptionsService.prototype.setupOptions = function (options) {
        var _this = this;
        if (options) {
            if (!Array.isArray(options)) {
                options = [options];
            }
            options.forEach(function (optionMap) {
                if (optionMap) {
                    Object.keys(optionMap).forEach(function (key) {
                        _this[camelCase(key)] = optionMap[key];
                    });
                }
            });
        }
    };
    OptionsService.prototype.getOptionFromService = function (category, key, service, defaultValue) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data, ex_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, service.detail({ category: category, key: key })];
                    case 1:
                        data = (_a.sent()).data;
                        return [2 /*return*/, this.parseOptionRawValue(data.value, defaultValue)];
                    case 2:
                        ex_1 = _a.sent();
                        return [2 /*return*/, defaultValue];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    OptionsService.prototype.parseOptionRawValue = function (rawValue, defaultValue) {
        var value;
        try {
            value = JSON.parse(rawValue);
        }
        catch (e) {
            value = isUndefined(rawValue) ? defaultValue : rawValue;
        }
        return value;
    };
    OptionsService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [HOOK_OPTIONS,] }] },
        { type: SystemOptionsService },
        { type: TenantOptionsService }
    ]; };
    OptionsService = tslib_1.__decorate([
        Injectable(),
        tslib_1.__param(0, Optional()), tslib_1.__param(0, Inject(HOOK_OPTIONS))
    ], OptionsService);
    return OptionsService;
}(ApplicationOptions));
export { OptionsService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3B0aW9ucy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGM4eS9uZ3gtY29tcG9uZW50cy8iLCJzb3VyY2VzIjpbImNvcmUvY29tbW9uL29wdGlvbnMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLGNBQWMsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM3RSxPQUFPLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUNuRCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUUxRCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUVyRixNQUFNLENBQUMsSUFBTSxZQUFZLEdBQUcsSUFBSSxjQUFjLENBQXVDLGFBQWEsQ0FBQyxDQUFDO0FBRXBHOzs7R0FHRztBQUVIO0lBQW9DLDBDQUFrQjtJQUVwRCx3QkFDb0MsT0FBTyxFQUNqQyxvQkFBMEMsRUFDMUMsbUJBQXlDO1FBSG5ELFlBS0UsaUJBQU8sU0FFUjtRQUxTLDBCQUFvQixHQUFwQixvQkFBb0IsQ0FBc0I7UUFDMUMseUJBQW1CLEdBQW5CLG1CQUFtQixDQUFzQjtRQUdqRCxLQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDOztJQUM3QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILDRCQUFHLEdBQUgsVUFBSSxTQUErQixFQUFFLFlBQWtCO1FBQ3JELElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUM1QixJQUFJLE9BQU8sS0FBSyxLQUFLLFdBQVcsRUFBRTtZQUNoQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1NBQ3BDO1FBQ0QsT0FBTyxPQUFPLEtBQUssS0FBSyxXQUFXLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxD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QyxDQUFDLFFBQVEsQ0FBQztTQUN6RDtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQzs7Z0RBM0dFLFFBQVEsWUFBSSxNQUFNLFNBQUMsWUFBWTtnQkFDRixvQkFBb0I7Z0JBQ3JCLG9CQUFvQjs7SUFMeEMsY0FBYztRQUQxQixVQUFVLEVBQUU7UUFJUixtQkFBQSxRQUFRLEVBQUUsQ0FBQSxFQUFFLG1CQUFBLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQTtPQUh4QixjQUFjLENBK0cxQjtJQUFELHFCQUFDO0NBQUEsQUEvR0QsQ0FBb0Msa0JBQWtCLEdBK0dyRDtTQS9HWSxjQUFjIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4sIE9wdGlvbmFsLCBJbmplY3QsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGNhbWVsQ2FzZSwgaXNVbmRlZmluZWQgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgQXBwbGljYXRpb25PcHRpb25zIH0gZnJvbSAnLi9BcHBsaWNhdGlvbk9wdGlvbnMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uRmFjdG9yeSB9IGZyb20gJy4vZXh0ZW5zaW9uLWhvb2tzJztcbmltcG9ydCB7IFN5c3RlbU9wdGlvbnNTZXJ2aWNlLCBUZW5hbnRPcHRpb25zU2VydmljZSB9IGZyb20gJ0BjOHkvbmd4LWNvbXBvbmVudHMvYXBpJztcblxuZXhwb3J0IGNvbnN0IEhPT0tfT1BUSU9OUyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxFeHRlbnNpb25GYWN0b3J5PEFwcGxpY2F0aW9uT3B0aW9ucz4+KCdBcHAgb3B0aW9ucycpO1xuXG4vKipcbiAqIEEgc2VydmljZSB0aGF0IGFsbG93cyB0byBzZXQgb3IgZ2V0IGFwcGxpY2F0aW9uIG9wdGlvbnNcbiAqIHdoaWNoIGNvbmZpZ3VyZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiB0aGUgVUkuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBPcHRpb25zU2VydmljZSBleHRlbmRzIEFwcGxpY2F0aW9uT3B0aW9ucyB7XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbiAgY29uc3RydWN0b3IoXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChIT09LX09QVElPTlMpIG9wdGlvbnMsXG4gICAgcHJpdmF0ZSBzeXN0ZW1PcHRpb25zU2VydmljZTogU3lzdGVtT3B0aW9uc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSB0ZW5hbnRPcHRpb25TZXJ2aWNlOiBUZW5hbnRPcHRpb25zU2VydmljZVxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2V0dXBPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXBwbGljYXRpb24gb3B0aW9uIHVzZWQgdG8gY29uZmlndXJlIHRoZSBVSS5cbiAgICogQHBhcmFtIG9wdGlvbktleSBUaGUgYXBwbGljYXRpb24gb3B0aW9ucyBrZXkuXG4gICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQSB2YWx1ZSB0byByZXR1cm4gaWYgbm9uIGlzIHNldC5cbiAgICovXG4gIGdldChvcHRpb25LZXk6IGtleW9mIE9wdGlvbnNTZXJ2aWNlLCBkZWZhdWx0VmFsdWU/OiBhbnkpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzW29wdGlvbktleV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhbHVlID0gdGhpc1tjYW1lbENhc2Uob3B0aW9uS2V5KV07XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhbiBhcHBsaWNhdGlvbiBvcHRpb24uXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBzZXQuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgKi9cbiAgc2V0KGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSB7XG4gICAgdGhpc1tjYW1lbENhc2Uoa2V5KV0gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHN1cHBvcnQgdXJsIGZyb20gdGVuYW50IG9wdGlvbnMuXG4gICAqIElmIHJlc3BvbnNlIHJldHVybnMgJzQwNCBub3QgZm91bmQnIGl0IGdldHMgdGhlIHN1cHBvcnQgdXJsIGZyb20gYXBwbGljYXRpb24gb3B0aW9ucy5cbiAgICogSWYgdGhlIHN1cHBvcnQgbGluayB3aXRoaW4gYXBwbGljYXRpb24gb3B0aW9ucyBpcyBub3QgcHJvdmlkZWQgdGhlIFVJIHdpbGwgdXNlIHRoZSBzeXN0ZW0gb3B0aW9ucy5cbiAgICogSXMgdGhlIHN1cHBvcnQgbGluayBleHBsaWNpdGx5IHNldCB0byBmYWxzZSBpdCB3aWxsIGJlIGhpZGRlbi5cbiAgICogTk9URTogVGhlIHRlbmFudCBvcHRpb24gZW5kcG9pbnQgcmV0dXJucyB0aGUgc3lzdGVtIG9wdGlvbiBzZXR0aW5nIGlmIG5vbiBpcyBzZXQgb24gdGhlIHRlbmFudC5cbiAgICpcbiAgICogQHJldHVybnMgUmV0dXJucyBzdXBwb3J0IHVybCBvciBmYWxzZS5cbiAgICovXG4gIGFzeW5jIGdldFN1cHBvcnRVcmwoKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMuc3VwcG9ydFVybCkpIHtcbiAgICAgIHRoaXMuc3VwcG9ydFVybCA9IGF3YWl0IHRoaXMuZ2V0VGVuYW50T3B0aW9uKCdjb25maWd1cmF0aW9uJywgJ3N5c3RlbS5zdXBwb3J0LnVybCcpO1xuICAgIH1cbiAgICByZXR1cm4gaXNVbmRlZmluZWQodGhpcy5zdXBwb3J0VXJsKSA/IGZhbHNlIDogdGhpcy5zdXBwb3J0VXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIHRlbmFudCBhbGxvd3MgdG8gc2hvdyB0aGUgYWN0aXZhdGUtc3VwcG9ydCB1c2VyIG1lbnUgZW50cnkuXG4gICAqL1xuICBhc3luYyBnZXRBY3RpdmF0ZVN1cHBvcnRVc2VyKCkge1xuICAgIHJldHVybiB0aGlzLmdldFN5c3RlbU9wdGlvbignc3VwcG9ydC11c2VyJywgJ2VuYWJsZWQnLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgdmFsdWUgZnJvbSB0aGUgc3lzdGVtIHNlcnZpY2UgYW5kIHBhcnNlcyBpdC5cbiAgICpcbiAgICogQHBhcmFtIGNhdGVnb3J5IFRoZSBjYXRlZ29yeSBmb3IgdGhpcyBvcHRpb24uXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBmb3IgdGhhdCBvcHRpb24uXG4gICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgVGhlIGRlZmF1bHQgaWYgdGhlIG9wdGlvbiB3YXMgbm90IGZvdW5kLlxuICAgKi9cbiAgYXN5bmMgZ2V0U3lzdGVtT3B0aW9uKGNhdGVnb3J5OiBzdHJpbmcsIGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU/OiBhbnkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25Gcm9tU2VydmljZShjYXRlZ29yeSwga2V5LCB0aGlzLnN5c3RlbU9wdGlvbnNTZXJ2aWNlLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSB2YWx1ZSBmcm9tIHRoZSB0ZW5hbnQgc2VydmljZSBhbmQgcGFyc2VzIGl0LlxuICAgKlxuICAgKiBAcGFyYW0gY2F0ZWdvcnkgVGhlIGNhdGVnb3J5IGZvciB0aGlzIG9wdGlvbi5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IGZvciB0aGF0IG9wdGlvbi5cbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBUaGUgZGVmYXVsdCBpZiB0aGUgb3B0aW9uIHdhcyBub3QgZm91bmQuXG4gICAqL1xuICBhc3luYyBnZXRUZW5hbnRPcHRpb24oY2F0ZWdvcnk6IHN0cmluZywga2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZT86IGFueSkge1xuICAgIHJldHVybiB0aGlzLmdldE9wdGlvbkZyb21TZXJ2aWNlKGNhdGVnb3J5LCBrZXksIHRoaXMudGVuYW50T3B0aW9uU2VydmljZSwgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBPcHRpb25zKG9wdGlvbnM6IGFueVtdIHwgbnVsbCkge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IFtvcHRpb25zXTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuZm9yRWFjaChvcHRpb25NYXAgPT4ge1xuICAgICAgICBpZiAob3B0aW9uTWFwKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXMob3B0aW9uTWFwKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICB0aGlzW2NhbWVsQ2FzZShrZXkpXSA9IG9wdGlvbk1hcFtrZXldO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldE9wdGlvbkZyb21TZXJ2aWNlKGNhdGVnb3J5LCBrZXksIHNlcnZpY2UsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHNlcnZpY2UuZGV0YWlsKHsgY2F0ZWdvcnksIGtleSB9KTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT3B0aW9uUmF3VmFsdWUoZGF0YS52YWx1ZSwgZGVmYXVsdFZhbHVlKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBhcnNlT3B0aW9uUmF3VmFsdWUocmF3VmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGxldCB2YWx1ZTtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSBKU09OLnBhcnNlKHJhd1ZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB2YWx1ZSA9IGlzVW5kZWZpbmVkKHJhd1ZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHJhd1ZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbiJdfQ==