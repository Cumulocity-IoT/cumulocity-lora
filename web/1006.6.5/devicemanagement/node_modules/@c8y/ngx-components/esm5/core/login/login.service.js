import * as tslib_1 from "tslib";
import { Injectable, Optional } from '@angular/core';
import { FetchClient, BasicAuth, ICredentials, SystemOptionsService, Realtime, UserService, TenantService, IAuthentication, CookieAuth } from '@c8y/client';
import { AppStateService } from '../common/ui-state.service';
import { AlertService } from '../alert/alert.service';
import { gettext } from '../i18n/gettext';
import { ApiService } from '@c8y/ngx-components/api';
import { switchMap } from 'rxjs/operators';
import { EMPTY } from 'rxjs';
import { LocationStrategy } from '@angular/common';
/**
 * Service to manage the login.
 */
var LoginService = /** @class */ (function () {
    function LoginService(client, basicAuth, cookieAuth, systemOptions, ui, user, tenant, realtime, alert, api, location) {
        this.client = client;
        this.basicAuth = basicAuth;
        this.cookieAuth = cookieAuth;
        this.systemOptions = systemOptions;
        this.ui = ui;
        this.user = user;
        this.tenant = tenant;
        this.realtime = realtime;
        this.alert = alert;
        this.api = api;
        this.location = location;
        this.rememberMe = false;
        this.TOKEN_KEY = '_tcy8';
        this.TFATOKEN_KEY = 'TFAToken';
        this.OAUTH2_INTERNAL_TYPE = 'OAUTH2_INTERNAL';
        this.isFirstLogin = true;
        // tslint:disable:max-line-length
        this.ERROR_MESSAGES = {
            minlength: gettext('Password must have at least 8 characters and no more than 32.'),
            password_missmatch: gettext('Password confirmation does not match.'),
            maxlength: gettext('Password must have at least 8 characters and no more than 32.'),
            password_strength: gettext('Your password is not strong enough. Please include numbers, lower and upper case characters'),
            remote_error: gettext('Server error occurred.'),
            email: gettext('Invalid email address.'),
            password_change: gettext('Your password is expired. Please set a new password.'),
            password_reset_token_expired: gettext('Password reset link expired. Please enter your email address to receive a new one.'),
            tfa_pin_invalid: gettext('The code you entered is invalid. Please try again.'),
            pattern_phonenumber: gettext('Invalid phone number format. Only digits, spaces, slashes ("/") and dashes ("-") allowed.'),
            pattern_newPassword: gettext('Password must have at least 8 characters and no more than 32 and can only contain letters, numbers and following symbols: `~!@#$%^&*()_|+-=?;:\'",.<>{}[]\\/'),
            international_number_required: gettext('International phone number required, in the format +49 9 876 543 210.'),
            phone_number_error: gettext('Could not update phone number.'),
            pinAlreadySent: gettext('The verification code was already sent. For a new verification code, please click on the link above.'),
            passwordConfirm: gettext('Password confirmation does not match.'),
            tfaExpired: gettext('Two-factor authentication token expired.')
        };
        // tslint:enable:max-line-length
        this.SUCCESS_MESSAGES = {
            password_changed: gettext('Password changed. You can now log in using new password.'),
            password_reset_requested: gettext('Password reset request has been sent. Please check your email.'),
            resend_sms: gettext('Verification code SMS resent.')
        };
        this.passwordStrengthSetting = {
            enforcePasswordStrength: false,
            greenMinLength: 0
        };
        this.localhostRegExp = new RegExp('localhost');
        this.localhostIpRegExp = new RegExp('127.0.0.1');
        this.showTenantRegExp = new RegExp('showTenant');
        this.autoLogout();
        this.initLoginOptions();
    }
    /**
     * Returns the current tenant.
     * @return The tenant name.
     */
    LoginService.prototype.getTenant = function () {
        return this.client.tenant;
    };
    LoginService.prototype.initLoginOptions = function () {
        var loginOptions = this.ui.state.loginOptions || [];
        var isOAuth2 = function (_a) {
            var type = _a.type, grantType = _a.grantType;
            return type === 'OAUTH2' && grantType === 'AUTHORIZATION_CODE';
        };
        this.loginMode = loginOptions.find(function (_a) {
            var type = _a.type;
            return type === 'OAUTH2_INTERNAL';
        }) ||
            loginOptions.find(function (_a) {
                var type = _a.type;
                return type === 'BASIC';
            }) ||
            loginOptions.find(isOAuth2) || { type: 'BASIC' };
        this.oauthOptions = loginOptions.find(isOAuth2) || {};
    };
    LoginService.prototype.redirectToOauth = function () {
        var initRequest = this.oauthOptions.initRequest;
        var fullPath = (this.location ? this.location._platformLocation : window).location
            .href;
        var redirectUrl = encodeURIComponent(fullPath);
        var originUriParam = (initRequest.includes('?') ? '&' : '?') + "originUri=" + redirectUrl;
        window.location.href = "" + initRequest + originUriParam;
    };
    LoginService.prototype.autoLogout = function () {
        var _this = this;
        var errorPattern = /invalid\scredentials.*pin.*generate/i;
        var isTfaExpired = function (data) {
            return data && typeof data.message === 'string' && errorPattern.test(data.message);
        };
        this.ui.currentUser
            .pipe(switchMap(function (u) {
            return u ? _this.api.hookResponse(function (_a) {
                var response = _a.response;
                return response.status === 401;
            }) : EMPTY;
        }))
            .subscribe(function (apiCall) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var response, willLogout, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        response = apiCall.response;
                        willLogout = false;
                        if (!isTfaExpired(response.data)) return [3 /*break*/, 1];
                        willLogout = true;
                        return [3 /*break*/, 3];
                    case 1:
                        if (!(typeof response.json === 'function')) return [3 /*break*/, 3];
                        return [4 /*yield*/, response.clone().json()];
                    case 2:
                        data = _a.sent();
                        if (isTfaExpired(data)) {
                            willLogout = true;
                        }
                        _a.label = 3;
                    case 3:
                        if (willLogout) {
                            this.logout(false);
                            setTimeout(function () { return _this.alert.danger(_this.ERROR_MESSAGES.tfaExpired); }, 500);
                        }
                        return [2 /*return*/];
                }
            });
        }); });
    };
    /**
     * Checks the password for the min length.
     * @return The min length or undefined if not configured.
     */
    LoginService.prototype.getGreenMinLength = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data, e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!this.passwordStrengthSetting.greenMinLength) return [3 /*break*/, 5];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.systemOptions.detail({
                                category: 'password',
                                key: 'green.min-length'
                            })];
                    case 2:
                        data = (_a.sent()).data;
                        this.passwordStrengthSetting.greenMinLength = Number(data.value);
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/, this.passwordStrengthSetting.greenMinLength];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Checks if password strength is enforced.
     * @return true if enforced.
     */
    LoginService.prototype.getEnforcePasswordStrength = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data, e_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!this.passwordStrengthSetting.enforcePasswordStrength) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.systemOptions.detail({
                                category: 'password',
                                key: 'enforce.strength'
                            })];
                    case 2:
                        data = (_a.sent()).data;
                        this.passwordStrengthSetting.enforcePasswordStrength = data.value === 'true';
                        return [3 /*break*/, 4];
                    case 3:
                        e_2 = _a.sent();
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/, this.passwordStrengthSetting.enforcePasswordStrength];
                }
            });
        });
    };
    /**
     * Clears all backend errors.
     */
    LoginService.prototype.cleanMessages = function () {
        this.alert.clearAll();
    };
    /**
     * Adds a new success message
     * @param successKey The key of the success message as used in SUCCESS_MESSAGES
     */
    LoginService.prototype.addSuccessMessage = function (successKey) {
        var successMessage = this.SUCCESS_MESSAGES[successKey];
        if (successMessage) {
            this.alert.add({
                text: successMessage,
                type: 'success',
                timeout: 0
            });
        }
    };
    /**
     * Returns the current strategy. Defaults to cookie, if a token
     * is found in local or session storage we switch to basic auth.
     * @returns The current auth strategy.
     */
    LoginService.prototype.getAuthStrategy = function () {
        var authStrategy = this.cookieAuth;
        var token = localStorage.getItem(this.TOKEN_KEY) || sessionStorage.getItem(this.TOKEN_KEY);
        var tfa = localStorage.getItem(this.TFATOKEN_KEY) || sessionStorage.getItem(this.TFATOKEN_KEY);
        if (token) {
            authStrategy = this.basicAuth;
            this.setCredentials({ token: token, tfa: tfa }, this.basicAuth);
        }
        return authStrategy;
    };
    /**
     * Forces the use of basic auth as strategy with this credentials.
     * @param credentials The credentials to use.
     */
    LoginService.prototype.useBasicAuth = function (credentials) {
        this.setCredentials(credentials, this.basicAuth);
        return this.basicAuth;
    };
    /**
     * Tries to login a user with the given credentials.
     * If successful, the current tenant and user is set. If not an error
     * is thrown. It also verifies if the user is allowed to open the
     * current app.
     * @param auth The authentication strategy used.
     * @param credentials The credentials to try to login.
     */
    LoginService.prototype.login = function (auth, credentials) {
        if (auth === void 0) { auth = this.getAuthStrategy(); }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var tenantRes, tenant, userRes, user, token;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.client.setAuth(auth);
                        return [4 /*yield*/, this.tenant.current()];
                    case 1:
                        tenantRes = _a.sent();
                        tenant = tenantRes.data;
                        return [4 /*yield*/, this.switchLoginMode(credentials)];
                    case 2:
                        if (_a.sent()) {
                            auth = this.cookieAuth;
                        }
                        return [4 /*yield*/, this.user.current()];
                    case 3:
                        userRes = _a.sent();
                        user = userRes.data;
                        return [4 /*yield*/, this.verifyAppAccess()];
                    case 4:
                        _a.sent();
                        token = this.setCredentials({
                            tenant: tenant.name,
                            user: user.userName
                        }, auth);
                        if (token) {
                            this.storeBasicAuthToken(token);
                        }
                        return [4 /*yield*/, this.authFulfilled(tenant, user)];
                    case 5:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Saves tenant and user to the app state
     * @param tenant The current tenant object.
     * @param user The current user objet
     */
    LoginService.prototype.authFulfilled = function (tenant, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!tenant) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.tenant.current()];
                    case 1:
                        data = (_a.sent()).data;
                        tenant = data;
                        this.client.tenant = tenant.name;
                        _a.label = 2;
                    case 2:
                        if (!!user) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.user.current()];
                    case 3:
                        data = (_a.sent()).data;
                        user = data;
                        _a.label = 4;
                    case 4:
                        this.ui.currentUser.next(user);
                        this.ui.currentTenant.next(tenant);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Switch the login mode to CookieAuth if the
     * user has configured to use it in loginOptions.
     * @param credentials The credentials for that login
     */
    LoginService.prototype.switchLoginMode = function (credentials) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var isPasswordGrantLogin, params, urlParams, res;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        isPasswordGrantLogin = this.isPasswordGrantLogin(credentials);
                        if (!(isPasswordGrantLogin && credentials)) return [3 /*break*/, 2];
                        params = new URLSearchParams({
                            grant_type: 'PASSWORD',
                            username: credentials.user,
                            password: credentials.password,
                            tfa_code: credentials.tfa
                        });
                        urlParams = new URLSearchParams(this.loginMode.initRequest.split('?').pop());
                        credentials.tenant = urlParams.get('tenant_id');
                        return [4 /*yield*/, this.client.fetch("tenant/oauth?" + urlParams.toString(), {
                                method: 'POST',
                                body: params.toString(),
                                headers: {
                                    'content-type': 'application/x-www-form-urlencoded;charset=UTF-8'
                                }
                            })];
                    case 1:
                        res = _a.sent();
                        if (!res.ok) {
                            throw { res: res };
                        }
                        this.client.setAuth(this.cookieAuth);
                        this.cleanLocalStorage();
                        this.basicAuth.logout();
                        _a.label = 2;
                    case 2: return [2 /*return*/, isPasswordGrantLogin];
                }
            });
        });
    };
    LoginService.prototype.isPasswordGrantLogin = function (credentials) {
        var isSupportUser = credentials && credentials.user.includes('$');
        return !!(!isSupportUser &&
            this.loginMode &&
            this.loginMode.type === this.OAUTH2_INTERNAL_TYPE);
    };
    /**
     * Verifies if the tenant input field should be shown
     * or not.
     * @returns If true, show the tenant input.
     */
    LoginService.prototype.showTenant = function () {
        return !this.ui.state.loginOptions || this.isLocal() || this.isShowTenant();
    };
    /**
     * Logs the user out
     * @param reload If set to false, the page will not reload
     */
    LoginService.prototype.logout = function (reload) {
        if (reload === void 0) { reload = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var resData, _a, basicRes, cookieRes, ex_1;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        resData = null;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 4, 5, 6]);
                        return [4 /*yield*/, this.reset()];
                    case 2:
                        _a = tslib_1.__read.apply(void 0, [_b.sent(), 2]), basicRes = _a[0], cookieRes = _a[1];
                        return [4 /*yield*/, cookieRes.json()];
                    case 3:
                        resData = _b.sent();
                        return [3 /*break*/, 6];
                    case 4:
                        ex_1 = _b.sent();
                        this.alert.removeLastDanger();
                        return [3 /*break*/, 6];
                    case 5:
                        if (resData && resData.url) {
                            this.redirect(resData.url);
                        }
                        else if (reload) {
                            window.location.reload();
                        }
                        return [7 /*endfinally*/];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Resets the stored auth-data
     */
    LoginService.prototype.reset = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.cleanLocalStorage();
                this.cleanSessionStorage();
                this.realtime.disconnect();
                this.ui.currentUser.next(null);
                return [2 /*return*/, Promise.all([this.basicAuth.logout(), this.cookieAuth.logout()])];
            });
        });
    };
    /**
     * Saves the TFA token to local or session storage.
     * @param tfaToken The tfa token to save.
     * @param storage The storage to use (local or session).
     */
    LoginService.prototype.saveTFAToken = function (tfaToken, storage) {
        storage.setItem(this.TFATOKEN_KEY, tfaToken);
    };
    /**
     * Request the manifest -> on 401 user has no access to that application
     * and we throw the error up to the login form.
     */
    LoginService.prototype.verifyAppAccess = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var ex_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.ui.loadManifest()];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        ex_2 = _a.sent();
                        if (!(ex_2.res && ex_2.res.status === 404 && this.isLocal())) {
                            throw ex_2;
                        }
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets the tenant to the client and updates the credentials on the
     * auth strategy.
     * @param credentials The name of the tenant.
     * @param authStrategy The authentication strategy used.
     * @return Returns the token if basic auth, otherwise undefined.
     */
    LoginService.prototype.setCredentials = function (credentials, authStrategy) {
        if (credentials.tenant) {
            this.client.tenant = credentials.tenant;
        }
        // Check if a token is already set (case for support user login)
        // if yes -> we just need to update the user, and reuse the token
        // of the support user.
        // Therefore we need to pass user and tenant, to get
        // just the stored token and nothing else (see BasicAuth.ts:31).
        var token = this.basicAuth.updateCredentials({
            tenant: credentials.tenant,
            user: credentials.user
        });
        var newCredentials = tslib_1.__assign({ token: token }, credentials);
        return authStrategy.updateCredentials(newCredentials);
    };
    /**
     * Verifies if the current user is a developer or not.
     * Running on localhost means development mode.
     */
    LoginService.prototype.isLocal = function () {
        var hostname = window.location.hostname;
        return this.localhostIpRegExp.test(hostname) || this.localhostRegExp.test(hostname);
    };
    /**
     * Save the token to local or session storage.
     * @param token The token to save.
     * @param storage The storage to use (local or session).
     */
    LoginService.prototype.saveToken = function (token, storage) {
        storage.setItem(this.TOKEN_KEY, token);
    };
    LoginService.prototype.storeBasicAuthToken = function (token) {
        this.saveToken(token, sessionStorage);
        if (this.rememberMe) {
            this.saveToken(token, localStorage);
        }
    };
    LoginService.prototype.cleanLocalStorage = function () {
        localStorage.removeItem(this.TOKEN_KEY);
        localStorage.removeItem(this.TFATOKEN_KEY);
    };
    LoginService.prototype.cleanSessionStorage = function () {
        sessionStorage.removeItem(this.TOKEN_KEY);
        sessionStorage.removeItem(this.TFATOKEN_KEY);
    };
    LoginService.prototype.isShowTenant = function () {
        return this.showTenantRegExp.test(window.location.href);
    };
    LoginService.prototype.redirect = function (url) {
        window.location.href = url;
    };
    LoginService.ctorParameters = function () { return [
        { type: FetchClient },
        { type: BasicAuth },
        { type: CookieAuth },
        { type: SystemOptionsService },
        { type: AppStateService },
        { type: UserService },
        { type: TenantService },
        { type: Realtime },
        { type: AlertService },
        { type: ApiService },
        { type: LocationStrategy, decorators: [{ type: Optional }] }
    ]; };
    LoginService = tslib_1.__decorate([
        Injectable(),
        tslib_1.__param(10, Optional())
    ], LoginService);
    return LoginService;
}());
export { LoginService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9naW4uc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BjOHkvbmd4LWNvbXBvbmVudHMvIiwic291cmNlcyI6WyJjb3JlL2xvZ2luL2xvZ2luLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3JELE9BQU8sRUFDTCxXQUFXLEVBQ1gsU0FBUyxFQUNULFlBQVksRUFDWixvQkFBb0IsRUFDcEIsUUFBUSxFQUNSLFdBQVcsRUFDWCxhQUFhLEVBQ2IsZUFBZSxFQUNmLFVBQVUsRUFDWCxNQUFNLGFBQWEsQ0FBQztBQUNyQixPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDN0QsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3RELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMxQyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDckQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDN0IsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFbkQ7O0dBRUc7QUFFSDtJQTJERSxzQkFDVSxNQUFtQixFQUNuQixTQUFvQixFQUNwQixVQUFzQixFQUN0QixhQUFtQyxFQUNuQyxFQUFtQixFQUNuQixJQUFpQixFQUNqQixNQUFxQixFQUNyQixRQUFrQixFQUNsQixLQUFtQixFQUNuQixHQUFlLEVBQ0gsUUFBMEI7UUFWdEMsV0FBTSxHQUFOLE1BQU0sQ0FBYTtRQUNuQixjQUFTLEdBQVQsU0FBUyxDQUFXO1FBQ3BCLGVBQVUsR0FBVixVQUFVLENBQVk7UUFDdEIsa0JBQWEsR0FBYixhQUFhLENBQXNCO1FBQ25DLE9BQUUsR0FBRixFQUFF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RSxjQUFjLENBQUMsQ0FBQztRQUN0QyxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDbkIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUM7U0FDckM7SUFDSCxDQUFDO0lBRU8sd0NBQWlCLEdBQXpCO1FBQ0UsWUFBWSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDeEMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVPLDBDQUFtQixHQUEzQjtRQUNFLGNBQWMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFFTyxtQ0FBWSxHQUFwQjtRQUNFLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzFELENBQUM7SUFFTywrQkFBUSxHQUFoQixVQUFpQixHQUFXO1FBQzFCLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQztJQUM3QixDQUFDOztnQkFyWWlCLFdBQVc7Z0JBQ1IsU0FBUztnQkFDUixVQUFVO2dCQUNQLG9CQUFvQjtnQkFDL0IsZUFBZTtnQkFDYixXQUFXO2dCQUNULGFBQWE7Z0JBQ1gsUUFBUTtnQkFDWCxZQUFZO2dCQUNkLFVBQVU7Z0JBQ08sZ0JBQWdCLHVCQUE3QyxRQUFROztJQXRFQSxZQUFZO1FBRHhCLFVBQVUsRUFBRTtRQXVFUixvQkFBQSxRQUFRLEVBQUUsQ0FBQTtPQXRFRixZQUFZLENBa2N4QjtJQUFELG1CQUFDO0NBQUEsQUFsY0QsSUFrY0M7U0FsY1ksWUFBWSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBGZXRjaENsaWVudCxcbiAgQmFzaWNBdXRoLFxuICBJQ3JlZGVudGlhbHMsXG4gIFN5c3RlbU9wdGlvbnNTZXJ2aWNlLFxuICBSZWFsdGltZSxcbiAgVXNlclNlcnZpY2UsXG4gIFRlbmFudFNlcnZpY2UsXG4gIElBdXRoZW50aWNhdGlvbixcbiAgQ29va2llQXV0aFxufSBmcm9tICdAYzh5L2NsaWVudCc7XG5pbXBvcnQgeyBBcHBTdGF0ZVNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vdWktc3RhdGUuc2VydmljZSc7XG5pbXBvcnQgeyBBbGVydFNlcnZpY2UgfSBmcm9tICcuLi9hbGVydC9hbGVydC5zZXJ2aWNlJztcbmltcG9ydCB7IGdldHRleHQgfSBmcm9tICcuLi9pMThuL2dldHRleHQnO1xuaW1wb3J0IHsgQXBpU2VydmljZSB9IGZyb20gJ0BjOHkvbmd4LWNvbXBvbmVudHMvYXBpJztcbmltcG9ydCB7IHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEVNUFRZIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBMb2NhdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIG1hbmFnZSB0aGUgbG9naW4uXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBMb2dpblNlcnZpY2Uge1xuICByZW1lbWJlck1lOiBib29sZWFuID0gZmFsc2U7XG4gIFRPS0VOX0tFWTogc3RyaW5nID0gJ190Y3k4JztcbiAgVEZBVE9LRU5fS0VZOiBzdHJpbmcgPSAnVEZBVG9rZW4nO1xuICBPQVVUSDJfSU5URVJOQUxfVFlQRTogc3RyaW5nID0gJ09BVVRIMl9JTlRFUk5BTCc7XG4gIGxvZ2luTW9kZTogYW55O1xuICBvYXV0aE9wdGlvbnM6IGFueTtcbiAgaXNGaXJzdExvZ2luID0gdHJ1ZTtcblxuICAvLyB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGhcbiAgRVJST1JfTUVTU0FHRVMgPSB7XG4gICAgbWlubGVuZ3RoOiBnZXR0ZXh0KCdQYXNzd29yZCBtdXN0IGhhdmUgYXQgbGVhc3QgOCBjaGFyYWN0ZXJzIGFuZCBubyBtb3JlIHRoYW4gMzIuJyksXG4gICAgcGFzc3dvcmRfbWlzc21hdGNoOiBnZXR0ZXh0KCdQYXNzd29yZCBjb25maXJtYXRpb24gZG9lcyBub3QgbWF0Y2guJyksXG4gICAgbWF4bGVuZ3RoOiBnZXR0ZXh0KCdQYXNzd29yZCBtdXN0IGhhdmUgYXQgbGVhc3QgOCBjaGFyYWN0ZXJzIGFuZCBubyBtb3JlIHRoYW4gMzIuJyksXG4gICAgcGFzc3dvcmRfc3RyZW5ndGg6IGdldHRleHQoXG4gICAgICAnWW91ciBwYXNzd29yZCBpcyBub3Qgc3Ryb25nIGVub3VnaC4gUGxlYXNlIGluY2x1ZGUgbnVtYmVycywgbG93ZXIgYW5kIHVwcGVyIGNhc2UgY2hhcmFjdGVycydcbiAgICApLFxuICAgIHJlbW90ZV9lcnJvcjogZ2V0dGV4dCgnU2VydmVyIGVycm9yIG9jY3VycmVkLicpLFxuICAgIGVtYWlsOiBnZXR0ZXh0KCdJbnZhbGlkIGVtYWlsIGFkZHJlc3MuJyksXG4gICAgcGFzc3dvcmRfY2hhbmdlOiBnZXR0ZXh0KCdZb3VyIHBhc3N3b3JkIGlzIGV4cGlyZWQuIFBsZWFzZSBzZXQgYSBuZXcgcGFzc3dvcmQuJyksXG4gICAgcGFzc3dvcmRfcmVzZXRfdG9rZW5fZXhwaXJlZDogZ2V0dGV4dChcbiAgICAgICdQYXNzd29yZCByZXNldCBsaW5rIGV4cGlyZWQuIFBsZWFzZSBlbnRlciB5b3VyIGVtYWlsIGFkZHJlc3MgdG8gcmVjZWl2ZSBhIG5ldyBvbmUuJ1xuICAgICksXG4gICAgdGZhX3Bpbl9pbnZhbGlkOiBnZXR0ZXh0KCdUaGUgY29kZSB5b3UgZW50ZXJlZCBpcyBpbnZhbGlkLiBQbGVhc2UgdHJ5IGFnYWluLicpLFxuICAgIHBhdHRlcm5fcGhvbmVudW1iZXI6IGdldHRleHQoXG4gICAgICAnSW52YWxpZCBwaG9uZSBudW1iZXIgZm9ybWF0LiBPbmx5IGRpZ2l0cywgc3BhY2VzLCBzbGFzaGVzIChcIi9cIikgYW5kIGRhc2hlcyAoXCItXCIpIGFsbG93ZWQuJ1xuICAgICksXG4gICAgcGF0dGVybl9uZXdQYXNzd29yZDogZ2V0dGV4dChcbiAgICAgICdQYXNzd29yZCBtdXN0IGhhdmUgYXQgbGVhc3QgOCBjaGFyYWN0ZXJzIGFuZCBubyBtb3JlIHRoYW4gMzIgYW5kIGNhbiBvbmx5IGNvbnRhaW4gbGV0dGVycywgbnVtYmVycyBhbmQgZm9sbG93aW5nIHN5bWJvbHM6IGB+IUAjJCVeJiooKV98Ky09Pzs6XFwnXCIsLjw+e31bXVxcXFwvJ1xuICAgICksXG4gICAgaW50ZXJuYXRpb25hbF9udW1iZXJfcmVxdWlyZWQ6IGdldHRleHQoXG4gICAgICAnSW50ZXJuYXRpb25hbCBwaG9uZSBudW1iZXIgcmVxdWlyZWQsIGluIHRoZSBmb3JtYXQgKzQ5IDkgODc2IDU0MyAyMTAuJ1xuICAgICksXG4gICAgcGhvbmVfbnVtYmVyX2Vycm9yOiBnZXR0ZXh0KCdDb3VsZCBub3QgdXBkYXRlIHBob25lIG51bWJlci4nKSxcbiAgICBwaW5BbHJlYWR5U2VudDogZ2V0dGV4dChcbiAgICAgICdUaGUgdmVyaWZpY2F0aW9uIGNvZGUgd2FzIGFscmVhZHkgc2VudC4gRm9yIGEgbmV3IHZlcmlmaWNhdGlvbiBjb2RlLCBwbGVhc2UgY2xpY2sgb24gdGhlIGxpbmsgYWJvdmUuJ1xuICAgICksXG4gICAgcGFzc3dvcmRDb25maXJtOiBnZXR0ZXh0KCdQYXNzd29yZCBjb25maXJtYXRpb24gZG9lcyBub3QgbWF0Y2guJyksXG4gICAgdGZhRXhwaXJlZDogZ2V0dGV4dCgnVHdvLWZhY3RvciBhdXRoZW50aWNhdGlvbiB0b2tlbiBleHBpcmVkLicpXG4gIH07XG4gIC8vIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoXG5cbiAgcHJpdmF0ZSBTVUNDRVNTX01FU1NBR0VTID0ge1xuICAgIHBhc3N3b3JkX2NoYW5nZWQ6IGdldHRleHQoJ1Bhc3N3b3JkIGNoYW5nZWQuIFlvdSBjYW4gbm93IGxvZyBpbiB1c2luZyBuZXcgcGFzc3dvcmQuJyksXG4gICAgcGFzc3dvcmRfcmVzZXRfcmVxdWVzdGVkOiBnZXR0ZXh0KFxuICAgICAgJ1Bhc3N3b3JkIHJlc2V0IHJlcXVlc3QgaGFzIGJlZW4gc2VudC4gUGxlYXNlIGNoZWNrIHlvdXIgZW1haWwuJ1xuICAgICksXG4gICAgcmVzZW5kX3NtczogZ2V0dGV4dCgnVmVyaWZpY2F0aW9uIGNvZGUgU01TIHJlc2VudC4nKVxuICB9O1xuXG4gIHByaXZhdGUgcGFzc3dvcmRTdHJlbmd0aFNldHRpbmcgPSB7XG4gICAgZW5mb3JjZVBhc3N3b3JkU3RyZW5ndGg6IGZhbHNlLFxuICAgIGdyZWVuTWluTGVuZ3RoOiAwXG4gIH07XG5cbiAgcHJpdmF0ZSBsb2NhbGhvc3RSZWdFeHAgPSBuZXcgUmVnRXhwKCdsb2NhbGhvc3QnKTtcbiAgcHJpdmF0ZSBsb2NhbGhvc3RJcFJlZ0V4cCA9IG5ldyBSZWdFeHAoJzEyNy4wLjAuMScpO1xuICBwcml2YXRlIHNob3dUZW5hbnRSZWdFeHAgPSBuZXcgUmVnRXhwKCdzaG93VGVuYW50Jyk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjbGllbnQ6IEZldGNoQ2xpZW50LFxuICAgIHByaXZhdGUgYmFzaWNBdXRoOiBCYXNpY0F1dGgsXG4gICAgcHJpdmF0ZSBjb29raWVBdXRoOiBDb29raWVBdXRoLFxuICAgIHByaXZhdGUgc3lzdGVtT3B0aW9uczogU3lzdGVtT3B0aW9uc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSB1aTogQXBwU3RhdGVTZXJ2aWNlLFxuICAgIHByaXZhdGUgdXNlcjogVXNlclNlcnZpY2UsXG4gICAgcHJpdmF0ZSB0ZW5hbnQ6IFRlbmFudFNlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFsdGltZTogUmVhbHRpbWUsXG4gICAgcHJpdmF0ZSBhbGVydDogQWxlcnRTZXJ2aWNlLFxuICAgIHByaXZhdGUgYXBpOiBBcGlTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgbG9jYXRpb246IExvY2F0aW9uU3RyYXRlZ3lcbiAgKSB7XG4gICAgdGhpcy5hdXRvTG9nb3V0KCk7XG4gICAgdGhpcy5pbml0TG9naW5PcHRpb25zKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB0ZW5hbnQuXG4gICAqIEByZXR1cm4gVGhlIHRlbmFudCBuYW1lLlxuICAgKi9cbiAgZ2V0VGVuYW50KCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC50ZW5hbnQ7XG4gIH1cblxuICBpbml0TG9naW5PcHRpb25zKCkge1xuICAgIGNvbnN0IGxvZ2luT3B0aW9ucyA9IHRoaXMudWkuc3RhdGUubG9naW5PcHRpb25zIHx8IFtdO1xuICAgIGNvbnN0IGlzT0F1dGgyID0gKHsgdHlwZSwgZ3JhbnRUeXBlIH0pID0+XG4gICAgICB0eXBlID09PSAnT0FVVEgyJyAmJiBncmFudFR5cGUgPT09ICdBVVRIT1JJWkFUSU9OX0NPREUnO1xuICAgIHRoaXMubG9naW5Nb2RlID0gbG9naW5PcHRpb25zLmZpbmQoKHsgdHlwZSB9KSA9PiB0eXBlID09PSAnT0FVVEgyX0lOVEVSTkFMJykgfHxcbiAgICAgIGxvZ2luT3B0aW9ucy5maW5kKCh7IHR5cGUgfSkgPT4gdHlwZSA9PT0gJ0JBU0lDJykgfHxcbiAgICAgIGxvZ2luT3B0aW9ucy5maW5kKGlzT0F1dGgyKSB8fCB7IHR5cGU6ICdCQVNJQycgfTtcbiAgICB0aGlzLm9hdXRoT3B0aW9ucyA9IGxvZ2luT3B0aW9ucy5maW5kKGlzT0F1dGgyKSB8fCB7fTtcbiAgfVxuXG4gIHJlZGlyZWN0VG9PYXV0aCgpIHtcbiAgICBjb25zdCB7IGluaXRSZXF1ZXN0IH0gPSB0aGlzLm9hdXRoT3B0aW9ucztcbiAgICBjb25zdCBmdWxsUGF0aCA9ICh0aGlzLmxvY2F0aW9uID8gKHRoaXMubG9jYXRpb24gYXMgYW55KS5fcGxhdGZvcm1Mb2NhdGlvbiA6IHdpbmRvdykubG9jYXRpb25cbiAgICAgIC5ocmVmO1xuICAgIGNvbnN0IHJlZGlyZWN0VXJsID0gZW5jb2RlVVJJQ29tcG9uZW50KGZ1bGxQYXRoKTtcbiAgICBjb25zdCBvcmlnaW5VcmlQYXJhbSA9IGAke2luaXRSZXF1ZXN0LmluY2x1ZGVzKCc/JykgPyAnJicgOiAnPyd9b3JpZ2luVXJpPSR7cmVkaXJlY3RVcmx9YDtcbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGAke2luaXRSZXF1ZXN0fSR7b3JpZ2luVXJpUGFyYW19YDtcbiAgfVxuXG4gIGF1dG9Mb2dvdXQoKSB7XG4gICAgY29uc3QgZXJyb3JQYXR0ZXJuID0gL2ludmFsaWRcXHNjcmVkZW50aWFscy4qcGluLipnZW5lcmF0ZS9pO1xuICAgIGNvbnN0IGlzVGZhRXhwaXJlZCA9IGRhdGEgPT5cbiAgICAgIGRhdGEgJiYgdHlwZW9mIGRhdGEubWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgZXJyb3JQYXR0ZXJuLnRlc3QoZGF0YS5tZXNzYWdlKTtcbiAgICB0aGlzLnVpLmN1cnJlbnRVc2VyXG4gICAgICAucGlwZShcbiAgICAgICAgc3dpdGNoTWFwKHUgPT5cbiAgICAgICAgICB1ID8gdGhpcy5hcGkuaG9va1Jlc3BvbnNlKCh7IHJlc3BvbnNlIH0pID0+IHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSA6IEVNUFRZXG4gICAgICAgIClcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoYXN5bmMgKGFwaUNhbGw6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlc3BvbnNlIH0gPSBhcGlDYWxsO1xuICAgICAgICBsZXQgd2lsbExvZ291dCA9IGZhbHNlO1xuICAgICAgICBpZiAoaXNUZmFFeHBpcmVkKHJlc3BvbnNlLmRhdGEpKSB7XG4gICAgICAgICAgd2lsbExvZ291dCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5qc29uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuY2xvbmUoKS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoaXNUZmFFeHBpcmVkKGRhdGEpKSB7XG4gICAgICAgICAgICAgIHdpbGxMb2dvdXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2lsbExvZ291dCkge1xuICAgICAgICAgIHRoaXMubG9nb3V0KGZhbHNlKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYWxlcnQuZGFuZ2VyKHRoaXMuRVJST1JfTUVTU0FHRVMudGZhRXhwaXJlZCksIDUwMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgcGFzc3dvcmQgZm9yIHRoZSBtaW4gbGVuZ3RoLlxuICAgKiBAcmV0dXJuIFRoZSBtaW4gbGVuZ3RoIG9yIHVuZGVmaW5lZCBpZiBub3QgY29uZmlndXJlZC5cbiAgICovXG4gIGFzeW5jIGdldEdyZWVuTWluTGVuZ3RoKCkge1xuICAgIGlmICghdGhpcy5wYXNzd29yZFN0cmVuZ3RoU2V0dGluZy5ncmVlbk1pbkxlbmd0aCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCB0aGlzLnN5c3RlbU9wdGlvbnMuZGV0YWlsKHtcbiAgICAgICAgICBjYXRlZ29yeTogJ3Bhc3N3b3JkJyxcbiAgICAgICAgICBrZXk6ICdncmVlbi5taW4tbGVuZ3RoJ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wYXNzd29yZFN0cmVuZ3RoU2V0dGluZy5ncmVlbk1pbkxlbmd0aCA9IE51bWJlcihkYXRhLnZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFzc3dvcmRTdHJlbmd0aFNldHRpbmcuZ3JlZW5NaW5MZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBwYXNzd29yZCBzdHJlbmd0aCBpcyBlbmZvcmNlZC5cbiAgICogQHJldHVybiB0cnVlIGlmIGVuZm9yY2VkLlxuICAgKi9cbiAgYXN5bmMgZ2V0RW5mb3JjZVBhc3N3b3JkU3RyZW5ndGgoKSB7XG4gICAgaWYgKCF0aGlzLnBhc3N3b3JkU3RyZW5ndGhTZXR0aW5nLmVuZm9yY2VQYXNzd29yZFN0cmVuZ3RoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHRoaXMuc3lzdGVtT3B0aW9ucy5kZXRhaWwoe1xuICAgICAgICAgIGNhdGVnb3J5OiAncGFzc3dvcmQnLFxuICAgICAgICAgIGtleTogJ2VuZm9yY2Uuc3RyZW5ndGgnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhc3N3b3JkU3RyZW5ndGhTZXR0aW5nLmVuZm9yY2VQYXNzd29yZFN0cmVuZ3RoID0gZGF0YS52YWx1ZSA9PT0gJ3RydWUnO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhc3N3b3JkU3RyZW5ndGhTZXR0aW5nLmVuZm9yY2VQYXNzd29yZFN0cmVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgYmFja2VuZCBlcnJvcnMuXG4gICAqL1xuICBjbGVhbk1lc3NhZ2VzKCkge1xuICAgIHRoaXMuYWxlcnQuY2xlYXJBbGwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IHN1Y2Nlc3MgbWVzc2FnZVxuICAgKiBAcGFyYW0gc3VjY2Vzc0tleSBUaGUga2V5IG9mIHRoZSBzdWNjZXNzIG1lc3NhZ2UgYXMgdXNlZCBpbiBTVUNDRVNTX01FU1NBR0VTXG4gICAqL1xuICBhZGRTdWNjZXNzTWVzc2FnZShzdWNjZXNzS2V5OiBzdHJpbmcpIHtcbiAgICBjb25zdCBzdWNjZXNzTWVzc2FnZSA9IHRoaXMuU1VDQ0VTU19NRVNTQUdFU1tzdWNjZXNzS2V5XTtcbiAgICBpZiAoc3VjY2Vzc01lc3NhZ2UpIHtcbiAgICAgIHRoaXMuYWxlcnQuYWRkKHtcbiAgICAgICAgdGV4dDogc3VjY2Vzc01lc3NhZ2UsXG4gICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgdGltZW91dDogMFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RyYXRlZ3kuIERlZmF1bHRzIHRvIGNvb2tpZSwgaWYgYSB0b2tlblxuICAgKiBpcyBmb3VuZCBpbiBsb2NhbCBvciBzZXNzaW9uIHN0b3JhZ2Ugd2Ugc3dpdGNoIHRvIGJhc2ljIGF1dGguXG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IGF1dGggc3RyYXRlZ3kuXG4gICAqL1xuICBnZXRBdXRoU3RyYXRlZ3koKTogSUF1dGhlbnRpY2F0aW9uIHtcbiAgICBsZXQgYXV0aFN0cmF0ZWd5ID0gdGhpcy5jb29raWVBdXRoIGFzIElBdXRoZW50aWNhdGlvbjtcbiAgICBjb25zdCB0b2tlbjogc3RyaW5nID1cbiAgICAgIGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuVE9LRU5fS0VZKSB8fCBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHRoaXMuVE9LRU5fS0VZKTtcbiAgICBjb25zdCB0ZmE6IHN0cmluZyA9XG4gICAgICBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLlRGQVRPS0VOX0tFWSkgfHwgc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSh0aGlzLlRGQVRPS0VOX0tFWSk7XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBhdXRoU3RyYXRlZ3kgPSB0aGlzLmJhc2ljQXV0aDtcbiAgICAgIHRoaXMuc2V0Q3JlZGVudGlhbHMoeyB0b2tlbiwgdGZhIH0sIHRoaXMuYmFzaWNBdXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF1dGhTdHJhdGVneTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZXMgdGhlIHVzZSBvZiBiYXNpYyBhdXRoIGFzIHN0cmF0ZWd5IHdpdGggdGhpcyBjcmVkZW50aWFscy5cbiAgICogQHBhcmFtIGNyZWRlbnRpYWxzIFRoZSBjcmVkZW50aWFscyB0byB1c2UuXG4gICAqL1xuICB1c2VCYXNpY0F1dGgoY3JlZGVudGlhbHM6IElDcmVkZW50aWFscykge1xuICAgIHRoaXMuc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMsIHRoaXMuYmFzaWNBdXRoKTtcbiAgICByZXR1cm4gdGhpcy5iYXNpY0F1dGg7XG4gIH1cblxuICAvKipcbiAgICogVHJpZXMgdG8gbG9naW4gYSB1c2VyIHdpdGggdGhlIGdpdmVuIGNyZWRlbnRpYWxzLlxuICAgKiBJZiBzdWNjZXNzZnVsLCB0aGUgY3VycmVudCB0ZW5hbnQgYW5kIHVzZXIgaXMgc2V0LiBJZiBub3QgYW4gZXJyb3JcbiAgICogaXMgdGhyb3duLiBJdCBhbHNvIHZlcmlmaWVzIGlmIHRoZSB1c2VyIGlzIGFsbG93ZWQgdG8gb3BlbiB0aGVcbiAgICogY3VycmVudCBhcHAuXG4gICAqIEBwYXJhbSBhdXRoIFRoZSBhdXRoZW50aWNhdGlvbiBzdHJhdGVneSB1c2VkLlxuICAgKiBAcGFyYW0gY3JlZGVudGlhbHMgVGhlIGNyZWRlbnRpYWxzIHRvIHRyeSB0byBsb2dpbi5cbiAgICovXG4gIGFzeW5jIGxvZ2luKGF1dGg6IElBdXRoZW50aWNhdGlvbiA9IHRoaXMuZ2V0QXV0aFN0cmF0ZWd5KCksIGNyZWRlbnRpYWxzPzogSUNyZWRlbnRpYWxzKSB7XG4gICAgdGhpcy5jbGllbnQuc2V0QXV0aChhdXRoKTtcblxuICAgIGNvbnN0IHRlbmFudFJlcyA9IGF3YWl0IHRoaXMudGVuYW50LmN1cnJlbnQoKTtcbiAgICBjb25zdCB0ZW5hbnQgPSB0ZW5hbnRSZXMuZGF0YTtcblxuICAgIGlmIChhd2FpdCB0aGlzLnN3aXRjaExvZ2luTW9kZShjcmVkZW50aWFscykpIHtcbiAgICAgIGF1dGggPSB0aGlzLmNvb2tpZUF1dGg7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlclJlcyA9IGF3YWl0IHRoaXMudXNlci5jdXJyZW50KCk7XG4gICAgY29uc3QgdXNlciA9IHVzZXJSZXMuZGF0YTtcbiAgICBhd2FpdCB0aGlzLnZlcmlmeUFwcEFjY2VzcygpO1xuXG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLnNldENyZWRlbnRpYWxzKFxuICAgICAge1xuICAgICAgICB0ZW5hbnQ6IHRlbmFudC5uYW1lLFxuICAgICAgICB1c2VyOiB1c2VyLnVzZXJOYW1lXG4gICAgICB9LFxuICAgICAgYXV0aFxuICAgICk7XG5cbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIHRoaXMuc3RvcmVCYXNpY0F1dGhUb2tlbih0b2tlbik7XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5hdXRoRnVsZmlsbGVkKHRlbmFudCwgdXNlcik7XG4gIH1cblxuICAvKipcbiAgICogU2F2ZXMgdGVuYW50IGFuZCB1c2VyIHRvIHRoZSBhcHAgc3RhdGVcbiAgICogQHBhcmFtIHRlbmFudCBUaGUgY3VycmVudCB0ZW5hbnQgb2JqZWN0LlxuICAgKiBAcGFyYW0gdXNlciBUaGUgY3VycmVudCB1c2VyIG9iamV0XG4gICAqL1xuICBhc3luYyBhdXRoRnVsZmlsbGVkKHRlbmFudD8sIHVzZXI/KSB7XG4gICAgaWYgKCF0ZW5hbnQpIHtcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgdGhpcy50ZW5hbnQuY3VycmVudCgpO1xuICAgICAgdGVuYW50ID0gZGF0YTtcbiAgICAgIHRoaXMuY2xpZW50LnRlbmFudCA9IHRlbmFudC5uYW1lO1xuICAgIH1cblxuICAgIGlmICghdXNlcikge1xuICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCB0aGlzLnVzZXIuY3VycmVudCgpO1xuICAgICAgdXNlciA9IGRhdGE7XG4gICAgfVxuXG4gICAgdGhpcy51aS5jdXJyZW50VXNlci5uZXh0KHVzZXIpO1xuICAgIHRoaXMudWkuY3VycmVudFRlbmFudC5uZXh0KHRlbmFudCk7XG4gIH1cblxuICAvKipcbiAgICogU3dpdGNoIHRoZSBsb2dpbiBtb2RlIHRvIENvb2tpZUF1dGggaWYgdGhlXG4gICAqIHVzZXIgaGFzIGNvbmZpZ3VyZWQgdG8gdXNlIGl0IGluIGxvZ2luT3B0aW9ucy5cbiAgICogQHBhcmFtIGNyZWRlbnRpYWxzIFRoZSBjcmVkZW50aWFscyBmb3IgdGhhdCBsb2dpblxuICAgKi9cbiAgYXN5bmMgc3dpdGNoTG9naW5Nb2RlKGNyZWRlbnRpYWxzPzogSUNyZWRlbnRpYWxzKSB7XG4gICAgY29uc3QgaXNQYXNzd29yZEdyYW50TG9naW4gPSB0aGlzLmlzUGFzc3dvcmRHcmFudExvZ2luKGNyZWRlbnRpYWxzKTtcbiAgICBpZiAoaXNQYXNzd29yZEdyYW50TG9naW4gJiYgY3JlZGVudGlhbHMpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBncmFudF90eXBlOiAnUEFTU1dPUkQnLFxuICAgICAgICB1c2VybmFtZTogY3JlZGVudGlhbHMudXNlcixcbiAgICAgICAgcGFzc3dvcmQ6IGNyZWRlbnRpYWxzLnBhc3N3b3JkLFxuICAgICAgICB0ZmFfY29kZTogY3JlZGVudGlhbHMudGZhXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModGhpcy5sb2dpbk1vZGUuaW5pdFJlcXVlc3Quc3BsaXQoJz8nKS5wb3AoKSk7XG4gICAgICBjcmVkZW50aWFscy50ZW5hbnQgPSB1cmxQYXJhbXMuZ2V0KCd0ZW5hbnRfaWQnKTtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY2xpZW50LmZldGNoKGB0ZW5hbnQvb2F1dGg/JHt1cmxQYXJhbXMudG9TdHJpbmcoKX1gLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBwYXJhbXMudG9TdHJpbmcoKSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCEocmVzIGFzIFJlc3BvbnNlKS5vaykge1xuICAgICAgICB0aHJvdyB7IHJlcyB9O1xuICAgICAgfVxuICAgICAgdGhpcy5jbGllbnQuc2V0QXV0aCh0aGlzLmNvb2tpZUF1dGgpO1xuICAgICAgdGhpcy5jbGVhbkxvY2FsU3RvcmFnZSgpO1xuICAgICAgdGhpcy5iYXNpY0F1dGgubG9nb3V0KCk7XG4gICAgfVxuICAgIHJldHVybiBpc1Bhc3N3b3JkR3JhbnRMb2dpbjtcbiAgfVxuXG4gIGlzUGFzc3dvcmRHcmFudExvZ2luKGNyZWRlbnRpYWxzPzogSUNyZWRlbnRpYWxzKSB7XG4gICAgY29uc3QgaXNTdXBwb3J0VXNlciA9IGNyZWRlbnRpYWxzICYmIGNyZWRlbnRpYWxzLnVzZXIuaW5jbHVkZXMoJyQnKTtcbiAgICByZXR1cm4gISEoXG4gICAgICAhaXNTdXBwb3J0VXNlciAmJlxuICAgICAgdGhpcy5sb2dpbk1vZGUgJiZcbiAgICAgIHRoaXMubG9naW5Nb2RlLnR5cGUgPT09IHRoaXMuT0FVVEgyX0lOVEVSTkFMX1RZUEVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIGlmIHRoZSB0ZW5hbnQgaW5wdXQgZmllbGQgc2hvdWxkIGJlIHNob3duXG4gICAqIG9yIG5vdC5cbiAgICogQHJldHVybnMgSWYgdHJ1ZSwgc2hvdyB0aGUgdGVuYW50IGlucHV0LlxuICAgKi9cbiAgc2hvd1RlbmFudCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMudWkuc3RhdGUubG9naW5PcHRpb25zIHx8IHRoaXMuaXNMb2NhbCgpIHx8IHRoaXMuaXNTaG93VGVuYW50KCk7XG4gIH1cblxuICAvKipcbiAgICogTG9ncyB0aGUgdXNlciBvdXRcbiAgICogQHBhcmFtIHJlbG9hZCBJZiBzZXQgdG8gZmFsc2UsIHRoZSBwYWdlIHdpbGwgbm90IHJlbG9hZFxuICAgKi9cbiAgYXN5bmMgbG9nb3V0KHJlbG9hZCA9IHRydWUpIHtcbiAgICBsZXQgcmVzRGF0YSA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IFtiYXNpY1JlcywgY29va2llUmVzXSA9IGF3YWl0IHRoaXMucmVzZXQoKTtcbiAgICAgIHJlc0RhdGEgPSBhd2FpdCBjb29raWVSZXMuanNvbigpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB0aGlzLmFsZXJ0LnJlbW92ZUxhc3REYW5nZXIoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHJlc0RhdGEgJiYgcmVzRGF0YS51cmwpIHtcbiAgICAgICAgdGhpcy5yZWRpcmVjdChyZXNEYXRhLnVybCk7XG4gICAgICB9IGVsc2UgaWYgKHJlbG9hZCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgc3RvcmVkIGF1dGgtZGF0YVxuICAgKi9cbiAgYXN5bmMgcmVzZXQoKSB7XG4gICAgdGhpcy5jbGVhbkxvY2FsU3RvcmFnZSgpO1xuICAgIHRoaXMuY2xlYW5TZXNzaW9uU3RvcmFnZSgpO1xuICAgIHRoaXMucmVhbHRpbWUuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMudWkuY3VycmVudFVzZXIubmV4dChudWxsKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3RoaXMuYmFzaWNBdXRoLmxvZ291dCgpLCB0aGlzLmNvb2tpZUF1dGgubG9nb3V0KCldKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlcyB0aGUgVEZBIHRva2VuIHRvIGxvY2FsIG9yIHNlc3Npb24gc3RvcmFnZS5cbiAgICogQHBhcmFtIHRmYVRva2VuIFRoZSB0ZmEgdG9rZW4gdG8gc2F2ZS5cbiAgICogQHBhcmFtIHN0b3JhZ2UgVGhlIHN0b3JhZ2UgdG8gdXNlIChsb2NhbCBvciBzZXNzaW9uKS5cbiAgICovXG4gIHNhdmVURkFUb2tlbih0ZmFUb2tlbjogc3RyaW5nLCBzdG9yYWdlOiBTdG9yYWdlKSB7XG4gICAgc3RvcmFnZS5zZXRJdGVtKHRoaXMuVEZBVE9LRU5fS0VZLCB0ZmFUb2tlbik7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0aGUgbWFuaWZlc3QgLT4gb24gNDAxIHVzZXIgaGFzIG5vIGFjY2VzcyB0byB0aGF0IGFwcGxpY2F0aW9uXG4gICAqIGFuZCB3ZSB0aHJvdyB0aGUgZXJyb3IgdXAgdG8gdGhlIGxvZ2luIGZvcm0uXG4gICAqL1xuICBhc3luYyB2ZXJpZnlBcHBBY2Nlc3MoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMudWkubG9hZE1hbmlmZXN0KCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmICghKGV4LnJlcyAmJiBleC5yZXMuc3RhdHVzID09PSA0MDQgJiYgdGhpcy5pc0xvY2FsKCkpKSB7XG4gICAgICAgIHRocm93IGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZW5hbnQgdG8gdGhlIGNsaWVudCBhbmQgdXBkYXRlcyB0aGUgY3JlZGVudGlhbHMgb24gdGhlXG4gICAqIGF1dGggc3RyYXRlZ3kuXG4gICAqIEBwYXJhbSBjcmVkZW50aWFscyBUaGUgbmFtZSBvZiB0aGUgdGVuYW50LlxuICAgKiBAcGFyYW0gYXV0aFN0cmF0ZWd5IFRoZSBhdXRoZW50aWNhdGlvbiBzdHJhdGVneSB1c2VkLlxuICAgKiBAcmV0dXJuIFJldHVybnMgdGhlIHRva2VuIGlmIGJhc2ljIGF1dGgsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBwcml2YXRlIHNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzOiBJQ3JlZGVudGlhbHMsIGF1dGhTdHJhdGVneTogSUF1dGhlbnRpY2F0aW9uKSB7XG4gICAgaWYgKGNyZWRlbnRpYWxzLnRlbmFudCkge1xuICAgICAgdGhpcy5jbGllbnQudGVuYW50ID0gY3JlZGVudGlhbHMudGVuYW50O1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiBhIHRva2VuIGlzIGFscmVhZHkgc2V0IChjYXNlIGZvciBzdXBwb3J0IHVzZXIgbG9naW4pXG4gICAgLy8gaWYgeWVzIC0+IHdlIGp1c3QgbmVlZCB0byB1cGRhdGUgdGhlIHVzZXIsIGFuZCByZXVzZSB0aGUgdG9rZW5cbiAgICAvLyBvZiB0aGUgc3VwcG9ydCB1c2VyLlxuICAgIC8vIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIHBhc3MgdXNlciBhbmQgdGVuYW50LCB0byBnZXRcbiAgICAvLyBqdXN0IHRoZSBzdG9yZWQgdG9rZW4gYW5kIG5vdGhpbmcgZWxzZSAoc2VlIEJhc2ljQXV0aC50czozMSkuXG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLmJhc2ljQXV0aC51cGRhdGVDcmVkZW50aWFscyh7XG4gICAgICB0ZW5hbnQ6IGNyZWRlbnRpYWxzLnRlbmFudCxcbiAgICAgIHVzZXI6IGNyZWRlbnRpYWxzLnVzZXJcbiAgICB9KTtcbiAgICBjb25zdCBuZXdDcmVkZW50aWFscyA9IHsgdG9rZW4sIC4uLmNyZWRlbnRpYWxzIH07XG5cbiAgICByZXR1cm4gYXV0aFN0cmF0ZWd5LnVwZGF0ZUNyZWRlbnRpYWxzKG5ld0NyZWRlbnRpYWxzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmllcyBpZiB0aGUgY3VycmVudCB1c2VyIGlzIGEgZGV2ZWxvcGVyIG9yIG5vdC5cbiAgICogUnVubmluZyBvbiBsb2NhbGhvc3QgbWVhbnMgZGV2ZWxvcG1lbnQgbW9kZS5cbiAgICovXG4gIHByaXZhdGUgaXNMb2NhbCgpOiBib29sZWFuIHtcbiAgICBjb25zdCBob3N0bmFtZSA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGhvc3RJcFJlZ0V4cC50ZXN0KGhvc3RuYW1lKSB8fCB0aGlzLmxvY2FsaG9zdFJlZ0V4cC50ZXN0KGhvc3RuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlIHRoZSB0b2tlbiB0byBsb2NhbCBvciBzZXNzaW9uIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB0b2tlbiBUaGUgdG9rZW4gdG8gc2F2ZS5cbiAgICogQHBhcmFtIHN0b3JhZ2UgVGhlIHN0b3JhZ2UgdG8gdXNlIChsb2NhbCBvciBzZXNzaW9uKS5cbiAgICovXG4gIHByaXZhdGUgc2F2ZVRva2VuKHRva2VuOiBzdHJpbmcsIHN0b3JhZ2U6IFN0b3JhZ2UpIHtcbiAgICBzdG9yYWdlLnNldEl0ZW0odGhpcy5UT0tFTl9LRVksIHRva2VuKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RvcmVCYXNpY0F1dGhUb2tlbih0b2tlbjogc3RyaW5nKSB7XG4gICAgdGhpcy5zYXZlVG9rZW4odG9rZW4sIHNlc3Npb25TdG9yYWdlKTtcbiAgICBpZiAodGhpcy5yZW1lbWJlck1lKSB7XG4gICAgICB0aGlzLnNhdmVUb2tlbih0b2tlbiwgbG9jYWxTdG9yYWdlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNsZWFuTG9jYWxTdG9yYWdlKCkge1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuVE9LRU5fS0VZKTtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLlRGQVRPS0VOX0tFWSk7XG4gIH1cblxuICBwcml2YXRlIGNsZWFuU2Vzc2lvblN0b3JhZ2UoKSB7XG4gICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLlRPS0VOX0tFWSk7XG4gICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLlRGQVRPS0VOX0tFWSk7XG4gIH1cblxuICBwcml2YXRlIGlzU2hvd1RlbmFudCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zaG93VGVuYW50UmVnRXhwLnRlc3Qod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICB9XG5cbiAgcHJpdmF0ZSByZWRpcmVjdCh1cmw6IHN0cmluZykge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICB9XG59XG4iXX0=