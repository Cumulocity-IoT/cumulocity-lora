import * as tslib_1 from "tslib";
import { HttpClient } from '@angular/common/http';
import { of } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import { Inject, Injectable } from '@angular/core';
import { LOCALE_PATH } from './locale.path';
import { LANGUAGES } from './languages';
import { OptionsService } from '../common/options.service';
var TranslateCustomLoader = /** @class */ (function () {
    function TranslateCustomLoader(http, optionsService, path, languages) {
        if (path === void 0) { path = null; }
        if (languages === void 0) { languages = null; }
        this.http = http;
        this.optionsService = optionsService;
        this.path = path;
        this.languages = languages;
    }
    TranslateCustomLoader.prototype.getTranslation = function (lang) {
        var _this = this;
        var path = this.path || '';
        var url = "" + path + lang + ".json";
        if (this.languages && this.languages[lang] && this.languages[lang].url) {
            url = this.languages[lang].url;
        }
        return this.http.get(url).pipe(map(function (d) {
            if (_this.optionsService.langsDetails && _this.optionsService.langsDetails[lang]) {
                return tslib_1.__assign({}, d[lang], _this.optionsService.langsDetails[lang]);
            }
            return d[lang];
        }), catchError(function () { return of({}); }));
    };
    TranslateCustomLoader.ctorParameters = function () { return [
        { type: HttpClient },
        { type: OptionsService },
        { type: String, decorators: [{ type: Inject, args: [LOCALE_PATH,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [LANGUAGES,] }] }
    ]; };
    TranslateCustomLoader = tslib_1.__decorate([
        Injectable(),
        tslib_1.__param(2, Inject(LOCALE_PATH)),
        tslib_1.__param(3, Inject(LANGUAGES))
    ], TranslateCustomLoader);
    return TranslateCustomLoader;
}());
export { TranslateCustomLoader };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRlLmxvYWRlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BjOHkvbmd4LWNvbXBvbmVudHMvIiwic291cmNlcyI6WyJjb3JlL2kxOG4vdHJhbnNsYXRlLmxvYWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRWxELE9BQU8sRUFBYyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEMsT0FBTyxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNqRCxPQUFPLEVBQVksTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM3RCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzVDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDeEMsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBRzNEO0lBQ0UsK0JBQ1UsSUFBZ0IsRUFDaEIsY0FBOEIsRUFDVCxJQUFtQixFQUNyQixTQUFxQjtRQURuQixxQkFBQSxFQUFBLFdBQW1CO1FBQ3JCLDBCQUFBLEVBQUEsZ0JBQXFCO1FBSHhDLFNBQUksR0FBSixJQUFJLENBQVk7UUFDaEIsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBQ1QsU0FBSSxHQUFKLElBQUksQ0FBZTtRQUNyQixjQUFTLEdBQVQsU0FBUyxDQUFZO0lBQy9DLENBQUM7SUFFSiw4Q0FBYyxHQUFkLFVBQWUsSUFBWTtRQUEzQixpQkFnQkM7UUFmQyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUM3QixJQUFJLEdBQUcsR0FBRyxLQUFHLElBQUksR0FBRyxJQUFJLFVBQU8sQ0FBQztRQUNoQyxJQUFJLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRTtZQUN0RSxHQUFHLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUM7U0FDaEM7UUFFRCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FDNUIsR0FBRyxDQUFDLFVBQUEsQ0FBQztZQUNILElBQUksS0FBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLElBQUksS0FBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQzlFLDRCQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBSyxLQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBRzthQUNsRTtZQUNELE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2pCLENBQUMsQ0FBQyxFQUNGLFVBQVUsQ0FBQyxjQUFNLE9BQUEsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFOLENBQU0sQ0FBQyxDQUN6QixDQUFDO0lBQ0osQ0FBQzs7Z0JBdEJlLFVBQVU7Z0JBQ0EsY0FBYzs2Q0FDckMsTUFBTSxTQUFDLFdBQVc7Z0RBQ2xCLE1BQU0sU0FBQyxTQUFTOztJQUxSLHFCQUFxQjtRQURqQyxVQUFVLEVBQUU7UUFLUixtQkFBQSxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUE7UUFDbkIsbUJBQUEsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFBO09BTFQscUJBQXFCLENBeUJqQztJQUFELDRCQUFDO0NBQUEsQUF6QkQsSUF5QkM7U0F6QlkscUJBQXFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSHR0cENsaWVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IFRyYW5zbGF0ZUxvYWRlciB9IGZyb20gJ0BuZ3gtdHJhbnNsYXRlL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgY2F0Y2hFcnJvciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IE9wdGlvbmFsLCBJbmplY3QsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IExPQ0FMRV9QQVRIIH0gZnJvbSAnLi9sb2NhbGUucGF0aCc7XG5pbXBvcnQgeyBMQU5HVUFHRVMgfSBmcm9tICcuL2xhbmd1YWdlcyc7XG5pbXBvcnQgeyBPcHRpb25zU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9vcHRpb25zLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVHJhbnNsYXRlQ3VzdG9tTG9hZGVyIGltcGxlbWVudHMgVHJhbnNsYXRlTG9hZGVyIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBodHRwOiBIdHRwQ2xpZW50LFxuICAgIHByaXZhdGUgb3B0aW9uc1NlcnZpY2U6IE9wdGlvbnNTZXJ2aWNlLFxuICAgIEBJbmplY3QoTE9DQUxFX1BBVEgpIHByaXZhdGUgcGF0aDogc3RyaW5nID0gbnVsbCxcbiAgICBASW5qZWN0KExBTkdVQUdFUykgcHJpdmF0ZSBsYW5ndWFnZXM6IGFueSA9IG51bGxcbiAgKSB7fVxuXG4gIGdldFRyYW5zbGF0aW9uKGxhbmc6IHN0cmluZyk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMucGF0aCB8fCAnJztcbiAgICBsZXQgdXJsID0gYCR7cGF0aH0ke2xhbmd9Lmpzb25gO1xuICAgIGlmICh0aGlzLmxhbmd1YWdlcyAmJiB0aGlzLmxhbmd1YWdlc1tsYW5nXSAmJiB0aGlzLmxhbmd1YWdlc1tsYW5nXS51cmwpIHtcbiAgICAgIHVybCA9IHRoaXMubGFuZ3VhZ2VzW2xhbmddLnVybDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5odHRwLmdldCh1cmwpLnBpcGUoXG4gICAgICBtYXAoZCA9PiB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNTZXJ2aWNlLmxhbmdzRGV0YWlscyAmJiB0aGlzLm9wdGlvbnNTZXJ2aWNlLmxhbmdzRGV0YWlsc1tsYW5nXSkge1xuICAgICAgICAgIHJldHVybiB7IC4uLmRbbGFuZ10sIC4uLnRoaXMub3B0aW9uc1NlcnZpY2UubGFuZ3NEZXRhaWxzW2xhbmddIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRbbGFuZ107XG4gICAgICB9KSxcbiAgICAgIGNhdGNoRXJyb3IoKCkgPT4gb2Yoe30pKVxuICAgICk7XG4gIH1cbn1cbiJdfQ==