import * as tslib_1 from "tslib";
import { HttpClient } from '@angular/common/http';
import { of } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import { Inject, Injectable } from '@angular/core';
import { LOCALE_PATH } from './locale.path';
import { LANGUAGES } from './languages';
import { OptionsService } from '../common/options.service';
let TranslateCustomLoader = class TranslateCustomLoader {
    constructor(http, optionsService, path = null, languages = null) {
        this.http = http;
        this.optionsService = optionsService;
        this.path = path;
        this.languages = languages;
    }
    getTranslation(lang) {
        const path = this.path || '';
        let url = `${path}${lang}.json`;
        if (this.languages && this.languages[lang] && this.languages[lang].url) {
            url = this.languages[lang].url;
        }
        return this.http.get(url).pipe(map(d => {
            if (this.optionsService.langsDetails && this.optionsService.langsDetails[lang]) {
                return Object.assign({}, d[lang], this.optionsService.langsDetails[lang]);
            }
            return d[lang];
        }), catchError(() => of({})));
    }
};
TranslateCustomLoader.ctorParameters = () => [
    { type: HttpClient },
    { type: OptionsService },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_PATH,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [LANGUAGES,] }] }
];
TranslateCustomLoader = tslib_1.__decorate([
    Injectable(),
    tslib_1.__param(2, Inject(LOCALE_PATH)),
    tslib_1.__param(3, Inject(LANGUAGES))
], TranslateCustomLoader);
export { TranslateCustomLoader };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRlLmxvYWRlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BjOHkvbmd4LWNvbXBvbmVudHMvIiwic291cmNlcyI6WyJjb3JlL2kxOG4vdHJhbnNsYXRlLmxvYWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRWxELE9BQU8sRUFBYyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEMsT0FBTyxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNqRCxPQUFPLEVBQVksTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM3RCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzVDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDeEMsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBRzNELElBQWEscUJBQXFCLEdBQWxDLE1BQWEscUJBQXFCO0lBQ2hDLFlBQ1UsSUFBZ0IsRUFDaEIsY0FBOEIsRUFDVCxPQUFlLElBQUksRUFDckIsWUFBaUIsSUFBSTtRQUh4QyxTQUFJLEdBQUosSUFBSSxDQUFZO1FBQ2hCLG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtRQUNULFNBQUksR0FBSixJQUFJLENBQWU7UUFDckIsY0FBUyxHQUFULFNBQVMsQ0FBWTtJQUMvQyxDQUFDO0lBRUosY0FBYyxDQUFDLElBQVk7UUFDekIsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksSUFBSSxFQUFFLENBQUM7UUFDN0IsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsSUFBSSxPQUFPLENBQUM7UUFDaEMsSUFBSSxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUU7WUFDdEUsR0FBRyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDO1NBQ2hDO1FBRUQsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQzVCLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUNOLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQzlFLHlCQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBSyxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBRzthQUNsRTtZQUNELE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2pCLENBQUMsQ0FBQyxFQUNGLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FDekIsQ0FBQztJQUNKLENBQUM7Q0FDRixDQUFBOztZQXZCaUIsVUFBVTtZQUNBLGNBQWM7eUNBQ3JDLE1BQU0sU0FBQyxXQUFXOzRDQUNsQixNQUFNLFNBQUMsU0FBUzs7QUFMUixxQkFBcUI7SUFEakMsVUFBVSxFQUFFO0lBS1IsbUJBQUEsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFBO0lBQ25CLG1CQUFBLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQTtHQUxULHFCQUFxQixDQXlCakM7U0F6QlkscUJBQXFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSHR0cENsaWVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IFRyYW5zbGF0ZUxvYWRlciB9IGZyb20gJ0BuZ3gtdHJhbnNsYXRlL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgY2F0Y2hFcnJvciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IE9wdGlvbmFsLCBJbmplY3QsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IExPQ0FMRV9QQVRIIH0gZnJvbSAnLi9sb2NhbGUucGF0aCc7XG5pbXBvcnQgeyBMQU5HVUFHRVMgfSBmcm9tICcuL2xhbmd1YWdlcyc7XG5pbXBvcnQgeyBPcHRpb25zU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9vcHRpb25zLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVHJhbnNsYXRlQ3VzdG9tTG9hZGVyIGltcGxlbWVudHMgVHJhbnNsYXRlTG9hZGVyIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBodHRwOiBIdHRwQ2xpZW50LFxuICAgIHByaXZhdGUgb3B0aW9uc1NlcnZpY2U6IE9wdGlvbnNTZXJ2aWNlLFxuICAgIEBJbmplY3QoTE9DQUxFX1BBVEgpIHByaXZhdGUgcGF0aDogc3RyaW5nID0gbnVsbCxcbiAgICBASW5qZWN0KExBTkdVQUdFUykgcHJpdmF0ZSBsYW5ndWFnZXM6IGFueSA9IG51bGxcbiAgKSB7fVxuXG4gIGdldFRyYW5zbGF0aW9uKGxhbmc6IHN0cmluZyk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMucGF0aCB8fCAnJztcbiAgICBsZXQgdXJsID0gYCR7cGF0aH0ke2xhbmd9Lmpzb25gO1xuICAgIGlmICh0aGlzLmxhbmd1YWdlcyAmJiB0aGlzLmxhbmd1YWdlc1tsYW5nXSAmJiB0aGlzLmxhbmd1YWdlc1tsYW5nXS51cmwpIHtcbiAgICAgIHVybCA9IHRoaXMubGFuZ3VhZ2VzW2xhbmddLnVybDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5odHRwLmdldCh1cmwpLnBpcGUoXG4gICAgICBtYXAoZCA9PiB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNTZXJ2aWNlLmxhbmdzRGV0YWlscyAmJiB0aGlzLm9wdGlvbnNTZXJ2aWNlLmxhbmdzRGV0YWlsc1tsYW5nXSkge1xuICAgICAgICAgIHJldHVybiB7IC4uLmRbbGFuZ10sIC4uLnRoaXMub3B0aW9uc1NlcnZpY2UubGFuZ3NEZXRhaWxzW2xhbmddIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRbbGFuZ107XG4gICAgICB9KSxcbiAgICAgIGNhdGNoRXJyb3IoKCkgPT4gb2Yoe30pKVxuICAgICk7XG4gIH1cbn1cbiJdfQ==