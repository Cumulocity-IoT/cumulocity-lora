import { __awaiter, __decorate } from 'tslib';
import { ɵɵdefineInjectable, ɵɵinject, Injectable, NgModule } from '@angular/core';
import { AppStateService, OptionsService, CoreModule } from '@c8y/ngx-components';
import { filter, map, take, delay } from 'rxjs/operators';
import { BehaviorSubject, combineLatest, fromEvent } from 'rxjs';

/**
 * A service to manage the Gainsight integration. It allows to load the
 * tag and
 */
let GainsightService = class GainsightService {
    constructor(appState, options) {
        this.appState = appState;
        this.options = options;
        /**
         * A subject that emits the tag function as soon as a new tag is set.
         */
        this.tagFunction$ = new BehaviorSubject(null);
        this.GAINSIGHT_URL = 'web-sdk.aptrinsic.com/api/aptrinsic.js?a=';
        this.GAINSIGHT_GLOBAL_SCOPE = 'aptrinsic';
        this.SCRIPT_EXECUTION_WAIT_TIME = 500;
        this.OPTIONS_KEY_CATEGORY = 'gainsight';
        this.OPTIONS_KEY_NAME = 'api.key';
    }
    /**
     * Returns the tag global function which can be used to identify user
     * or add special events.
     */
    get tagFunction() {
        return window[this.GAINSIGHT_GLOBAL_SCOPE];
    }
    /**
     * Load the script tag and calls the identify function to start the tracking.
     * @param accountId The account where the user is registered. Could be the name of the tenant.
     * @param identify If set to false, only the tag is loaded.
     */
    loadTag(accountId, identify = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const scriptTag = document.createElement('script');
            const key = this.options.gainsightKey ||
                (yield this.options.getSystemOption(this.OPTIONS_KEY_CATEGORY, this.OPTIONS_KEY_NAME));
            if (key) {
                this.loadScriptTag(scriptTag, key);
                combineLatest(this.appState.currentUser, fromEvent(scriptTag, 'load'), this.appState.state$.pipe(filter(({ versions }) => versions.backend), map(({ versions }) => versions), take(1)))
                    .pipe(delay(this.SCRIPT_EXECUTION_WAIT_TIME), filter(([user, scriptEvent]) => !!(scriptEvent && user)))
                    .subscribe(([user, scriptEvent, versions]) => {
                    const instanceId = this.getInstanceIdFromUrl();
                    if (identify) {
                        this.identify(user.id, accountId, instanceId, versions.ui.ngx, versions.backend);
                    }
                    this.tagFunction$.next(this.tagFunction);
                });
            }
        });
    }
    /**
     * Identifies the user/account at Gainsight.
     * @param userId The user id which is given to Gainsight.
     * @param accountId The account id which is given to Gainsight (e.g. the tenant name)
     * @param versionUI The UI version used.
     * @param versionBE The BE version used.
     */
    identify(userId, accountId, instanceId, versionUI, versionBE) {
        const windowRef = window;
        windowRef[this.GAINSIGHT_GLOBAL_SCOPE]('identify', {
            id: `${userId}_${accountId}_${instanceId}`,
            versionUI,
            versionBE,
            instanceId
        }, {
            id: `${accountId}_${instanceId}`,
            instanceId
        });
    }
    loadScriptTag(scriptTag, key) {
        try {
            const windowRef = window;
            const firstTag = document.getElementsByTagName('script')[0];
            const protocol = location.protocol;
            const gainsightGlobalScope = this.GAINSIGHT_GLOBAL_SCOPE;
            scriptTag.src = `${protocol}//${this.GAINSIGHT_URL}${key}`;
            (windowRef[this.GAINSIGHT_GLOBAL_SCOPE] =
                windowRef[this.GAINSIGHT_GLOBAL_SCOPE] ||
                    // tslint:disable-next-line:only-arrow-functions
                    function () {
                        (windowRef[gainsightGlobalScope].q = windowRef[gainsightGlobalScope].q || []).push(arguments);
                    }),
                (windowRef[gainsightGlobalScope].p = key);
            scriptTag.async = true;
            firstTag.parentNode.insertBefore(scriptTag, firstTag);
        }
        catch (ex) {
            console.warn('Failed to load Gainsight PX', ex);
        }
    }
    getInstanceIdFromUrl() {
        const hostName = location.hostname;
        return hostName.substring(hostName.indexOf('.') + 1);
    }
};
GainsightService.ctorParameters = () => [
    { type: AppStateService },
    { type: OptionsService }
];
GainsightService.ngInjectableDef = ɵɵdefineInjectable({ factory: function GainsightService_Factory() { return new GainsightService(ɵɵinject(AppStateService), ɵɵinject(OptionsService)); }, token: GainsightService, providedIn: "root" });
GainsightService = __decorate([
    Injectable({
        providedIn: 'root'
    })
], GainsightService);

/**
 * This module enables an tenant to activate the product experience
 * software [Gainsight](https://www.gainsight.com/product-experience/) to help
 * and track user actions. Gainsight is only activated, if the tenant custom
 * property `gainsightEnabled` is set to true.
 */
let ProductExperienceModule = class ProductExperienceModule {
    constructor(appState, gainsightService) {
        appState.currentTenant
            .pipe(filter(Boolean))
            .subscribe(({ customProperties, name }) => {
            if (customProperties && customProperties.gainsightEnabled) {
                gainsightService.loadTag(name);
            }
        });
    }
};
ProductExperienceModule.ctorParameters = () => [
    { type: AppStateService },
    { type: GainsightService }
];
ProductExperienceModule = __decorate([
    NgModule({
        declarations: [],
        imports: [CoreModule],
        exports: [],
        providers: [GainsightService]
    })
], ProductExperienceModule);

/**
 * Generated bundle index. Do not edit.
 */

export { GainsightService, ProductExperienceModule };
//# sourceMappingURL=c8y-ngx-components-product-experience.js.map
